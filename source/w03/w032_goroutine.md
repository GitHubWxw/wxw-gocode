## 并发编程之` goroutine` 



` goroutine` 是Go语言中的轻量级线程实现，由Go运行时（runtime）管理。你将会发现，它的 使用出人意料得简单。 

- 并发的口号：不要通过共享内存来通信，而应该通过通信来共享内存。

### 快速入门

#### 1. 并发问题

假设我们需要实现一个函数Add()，它把两个参数相加，并将结果打印到屏幕上，具体代码 如下：

```go
func Add(x, y int) {
	z := x + y
	fmt.Println(z)
}
```

那么，如何让这个函数并发执行呢?具体代码如下：

```go
// 加入 go 关键字，开启协程
go Add(1, 1) 
```

是不是很简单?  

你应该已经猜到，“go”这个单词是关键。与普通的函数调用相比，这也是唯一的区别。

在一个函数调用前加上go关键字，这次调用就会在一个新的` goroutine` 中并发执行。当被调用 的函数返回时，这个` goroutine` 也自动结束了。

需要注意的是，**如果这个函数有返回值，那么这个 返回值会被丢弃**。

好了，现在让我们动手试一下吧，还是刚才Add()函数：

```go
package main

import (
	"fmt"
)

func main() {
	for i := 1; i <= 10; i++ {
		go Add(i, i)
	}
}

func Add(x, y int) {
	z := x + y
	fmt.Println(z)
}
```

在上面的代码里，我们在一个for循环中调用了10次Add()函数，它们是并发执行的。可是 当你编译执行了上面的代码，就会发现一些奇怪的现象:

- “什么？！屏幕上什么都没有，程序没有正常工作！

- ” 是什么原因呢？明明调用了10次Add()，应该有10次屏幕输出才对。要解释这个现象，就涉 及Go语言的程序执行机制了。

**Go语言执行机制：** 

Go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出， 且程序并不等待其他 ` goroutine` （非主` goroutine` ）结束。

对于上面的例子，主函数启动了10个 ` goroutine` ，然后返回，这时程序就退出了，而被启动的 执行Add(i, i)的 ` goroutine` 没有来得及执行，所以程序没有任何输出。 

OK，问题找到了，怎么解决呢？

提到这一点，估计写过多线程程序的读者就已经恍然大悟， 并且摩拳擦掌地准备使用：

- 类似 ` WaitForSingleObject` 之类的调用
- 或者写个自己很拿手的忙等待
- 或者 稍微先进一些的 ` sleep` 循环 **等待来等待所有线程执行完毕**。

在Go语言中有自己推荐的方式，它要比这些方法都优雅得多。 要让主函数等待所有 ` goroutine` 退出后再返回，如何知道 ` goroutine` 都退出了呢? 

这就引出了多个  ` goroutine` 之间通信的问题。下面 我们将主要解决这个问题。

#### 2. 并发通信

从上面的例子中可以看到，关键字go的引入使得在Go语言中并发编程变得简单而优雅，但 我们同时也应该意识到并发编程的原生复杂性，并时刻对并发中容易出现的问题保持警惕。别忘 了，我们的例子还不能正常工作呢。 

事实上，不管是什么平台，什么编程语言，不管在哪，并发都是一个大话题。话题大小通常 也直接对应于问题的大小。并发编程的难度在于协调，而协调就要通过交流。从这个角度看来，并发单元间的通信是最大的问题。

在工程上，有两种最常见的并发通信模型：**共享数据** 和 **消息。**

- **共享数据** 是指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。被共享的 数据可能有多种形式，比如内存数据块、磁盘文件、网络数据等。在实际工程应用中最常见的无疑是内存了，也就是常说的**共享内存**。 
- **消息机制** 认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发 单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。这有点类似于进程 的概念，每个进程不会被其他进程打扰，它只做好自己的工作就可以了。不同进程间靠消息来通 信，它们不会共享内存。Go语言提供的消息通信机制被称为channel。



### 调度模型 ` GPM` 

#### 1.  引言

` GPM(Goroutine-Processor-Machine)` 是 ` Golang` 语言的核心执行机制，为 ` Golang` 提供了可靠的高并发、低开销、网络通信友好的协程机制，同时为 ` channel` 机制提供了基础的保障。以 ` GPM` 模型为树干，基本牵扯到了 ` golang` 调度策略、` channel` 、网络通信、内存管理、垃圾回收、IL设计等一系列核心内容。个人感觉是理解 ` Golang` 设计/运行原理最好的入手点。

本次主要介绍 ` GPM` 模型的演化和设计思想、执行流程和调度策略，如有分析不到位的地方欢迎指正。

#### 2. 为什么需要调度器

我们知道 ` Golang`  运行时有一个运行时。运行时在用户空间而不是内核中执行计划任务（` goroutine` ），因此它更轻量级。它在系统资源使用和性能之间做了更好的权衡，尤其是在 IO 任务中。

##### 2.1 单进程时代

我们并不需要调度器，所有的任务都被序列化处理。这种模式有个明显的缺点：

- 只有一个进程，计算机必须一项一项的处理任务
- 进程阻塞时会浪费CPU 时间

##### 2.2 多进程/多线程时代

为了解决阻塞问题，我们可以让` cpu` 在当前进程阻塞时执行其他任务。并且，我们创建了一个方法，将` cpu` 时间划分为很小的时间片（大概` 10ms` ），并有时间限制地运行任务，以确保所有任务都可以执行。由于时间片的原因，所有任务似乎都在同一时间运行。

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-1.png" alt="process scheduling" style="zoom:50%;" />  

同时，CPU 还要处理进程所持有的上下文切换，创建、切换、销毁进程会消耗大量的系统资源。所以高并发情况下CPU有效使用率可能会偏低。在linux系统中，线程虽然重量更轻，但它们是CPU调度的基本单位。进度成本原则上类似于流程。

##### 2.3 协程的由来

更多进程/线程也会导致其它问题：

1. 内存占用高。在 32 位系统中，每个进程将使用`  4GB` 虚拟内存。每个线程至少要花费 ` 4MB` 。
2. 上下文切换时 CPU 使用率高。

工程师发现大部分消耗发生在内核空间。我们知道一个进程有“用户空间”和“内核空间”，当系统调用或时间片触发时，进程会进入内核空间……但是从操作系统的角度来看，不管它是什么状态，由操作系统控制的进程使用一个数据结构称为`PCB Process Control Block`. OS看不到协程的工作状态，它只关心线程或PCB结构。

- 我们可以将运行在内核空间的代码称为线程 （`thread`）.
- 可以将运行在用户空间的代码称为协程`Coroutine`。

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-2.png" alt="线程协程" style="zoom:50%;" />  

那么为了减少内核空间的消耗，我们是否应该将多个协程绑定到一个线程？当然是的。如果我们`schedule layer`在线程和协程之间添加一个，将 N 个协程绑定到一个线程，我们得到一个`N:1`模式。

在这种情况下，我们可以在用户空间完成大部分工作，而不是频繁切换到内核。但是一旦线程被阻塞，所有的协程都不能工作。并且多核 CPU 不能仅在一个物理线程中全速运行。

**继续优化调度器** ，我们可以将N个协程绑定到M个物理线程。更复杂的调度器可以结合多线程的性能和协程的轻量级。

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-3.png" alt="男：女" style="zoom:50%;" />  

线程和协程调度的区别：

- 在于**线程调度是抢占式**的，
- **协程是协作式**的，协程应该主动释放CPU。

##### 2.4 协程 时代

在协程模式下，开发者应该主动释放 CPU。当一个协程长时间占用 CPU，而其他协程很饿时，这可能会导致问题。

所以在 `golang`中，scheduler是抢占式的，` golang` 中的tasks命名为`goroutine`，通过channel进行通信共享数据。

`goroutines can run when other goroutine in the same thread blocked, runtime will help you do the scheduling, you have noting to do.`. 它是为多并发场景实现的，比如多进程与单进程。` Goroutine` 保留了协程的优点并具有更高的性能。

- ` goroutine` 只能通过`4KB`内存来设置。它非常轻巧。

#### 3. 弃用的 ` GM` 调度模型 

线程和` goroutine` 的关系我们已经知道了，这里的重点是`The Scheduler`.

现在在 ` golang`中使用的调度器是2012年重新设计的，因为存在性能问题，所以弃用了。下面简单介绍一下这个调度器的工作原理。

- **G：** 协程
- **M：** 机器，内核空间中的线程

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-4.png" alt="通用调度器" style="zoom:50%;" />  

使用全局队列，它有缺点：

1. 要创建、销毁、调度 G ，M 需要进行激烈的锁定竞争
2. 在 M 之间转移 G 会造成更多的额外消耗。比如M创建了一个新的` goroutine`  G'，要执行G'，它应该被推入队列并在其他M'中运行，G与G'有关系，所以这里本地性能很差
3. 频繁的系统调用导致线程阻塞增加系统消耗

#### 4.`  GPM` 调度模型

##### 4.1 ` GPM` 模型介绍

**` Goroutine` 调度器和 OS 调度器使用 M 连接，每个 M 是一个物理 OS 线程，OS 调度器调度 M 运行在一个真实的 CPU 内核中。** 

在这种模式中，线程是物理工作者，调度程序应该将 ` goroutine` 分派给一个线程。

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-1.jpeg" alt="GMP模式" style="zoom:50%;" />  

**G、P、M 职责** 

- **G：** ` goroutine`，go程序建立的用户线程。主要保存 ` goroutine`  的运行时栈信息（stack结构体）以及 CPU 的一些寄存器的值（` gobuf` 结构体），还有关联的M，全局队列中下个G等信息。
- **P：** processor 代表了`M`所需的上下文环境，也是处理用户级代码逻辑的处理器，可以看作一个局部调度器使go代码在一个线程上跑。
- **M：** machine 一个`M`直接关联一个os内核线程，用于执行G。 `M`会优先从关联的`P`的本地队列中直接获取待执行的`G`，它保存了 M 自身使用的栈信息、当 前正在 M 上执行的 G 信息、与之绑定的 P 信息。
- **P列表**：在创建程序的时候创建一个`P`列表， 最多有` $GOMAXPROCS`个，这环境变量可以通过操作系统中的环境变量设置（` 1W)` ），也可以通过Go程序中的` runtime.GOMAXPROCS()` 函数设置，默认为处理器的核心数，它代表了真正的并发度。
- **M列表**：当前操作系统分配到当前go程序的内核线程数，可以通过go语言中runtime/debug包中的` SetMaxThreads` 函数设置。当有一个`M`阻塞，会有一个新的M被创建；当有一个`M`空闲，会被回收或睡眠。
- **P的本地队列**：P维护一个runq_用来存放等待执行的` goroutine` ，新创建的`G`会优先放在`P`的本地队列，当本地队列满（` 256G` ）时，会放入`G`的全局队列。
- **全局队列**：如果`P`的本地队列已满，待执行的`G`就会放在全局队列中，`M`会先从关联的`P`的**本地队列中获取**待执行的`G`，没有的话，再到**全局队列**中获取；如果这里也没有了，就去**其他`P`的本地队列**中获取一些任务。

`GPM` 模型 在原有的GM模型基础上，引入 P层，**目标是解决**： 

1. 全局队列共享锁引发的性能问题，同时使得本地P中的G无锁化，空间局部性更好
2. 将M 层 ` Mcache` 下沉到P层，减少内存占用
3. 因频繁挂起引发大切换代价大幅下降 

**关于 P和 M的数量设置** 

- **P的数量**：由运行时包中的`GOMAXPROCS`环境变量或`GOMAXPROCS()`函数决定。这意味着有 ` PRAGMATICS`  协程在任何时候并发运行。
- **M的数量：** 
  - ` golang`  支持的最大线程数是 10000，但是 OS 通常不能创建这么多线程。所以我们可以忽略这个限制。
  - `SetMaxThreads()` 运行时/调试包中的函数可以设置最大线程数
  - **一旦当前线程被阻塞，它将创建一个新线程 ，当有一个`M`空闲，会被回收或睡眠。**

**注意：**M&P的编号没有关系。一旦当前 M 被阻塞，P 的 ` goroutine`  将在其他 M 中运行或创建一个新 M。所以即使 P 的数量是 1，也可能有太多的 M。

**什么时候 创建 P、M ** 

- **P**：`P`的个数确定后，由runtime创建。
- **M：** 如果没有足够的 M 来执行 P 的任务，则会创建它。例如，所有 M 都被阻止，将创建新的 M 来运行 P 的任务

##### 4.2 ` GPM` 调度策略

**重用**：重用线程，避免频繁创建、销毁线程。

1. 工作窃取：当没有 G 运行时，从 P 绑定的 P 中窃取 G，而不是销毁
2. Hand Off：当P被阻塞时，将P转移给其他空闲的M

**并发** ：有更多`  GOMAXPROCS`  协程同时运行。但是如果`  GOMACPROCS < CPU Cores` ，它也会设置并发限制。

**Preemptive(先发制人) **：协程必须主动放弃` cpu` 时间。但是在` golang` 中，一个` goroutine` 最多可以运行` 10ms` ，避免其他` goroutine` 饿死。

**全局 ` Goroutines`  队列**：当工作窃取失败时，M 可以从全局队列中拉取 ` goroutines`。 

##### 4.3  `GPM`工作流程

`go func(){} 之后发生了什么` 

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-2.jpeg" alt="img" style="zoom: 67%;" />  

1. 通过 ` go func() {}`  创建一个 ` goroutine` 。
2. 有两个队列可以存储G，本地队列是更好的选择，但如果本地已满，G将被发布到全局队列。
3. G 必须在 M 中运行，每个 M 对应一个 P，M 会在任务完成时从此 P 中拉出 goroutine。如果本地 P 为空，它将从其他 M 的 P 或全局队列中窃取。
4. M 持续运行以执行 goroutines
5. 当 M 被阻塞时，` Golang`  会将其与 P 分离，并在其他空闲 M 中运行 Gs 或创建一个新的 M。
6. 当 M 恢复时，TG 触发阻塞，将尝试获取一个空闲的 P，如果没有 P 空闲，M 将休眠，G 将被发布到全局队列。

##### 4.4 ` GPM`生命周期  

和其它的语言设计类似，`Golang` 在启动时并不是从我们写的 ` main.main` 启动，而是在外面包了一层 ` runtime.main` 作为启动的入口。对于`golang` 本身来说：

```go
1. 设置运行参数
2. 启动 sysmon 作为监控
3. 启动 GC 机制
4. 启动 panic 保护
5. 调用 main.main 执行用户代码
6. 竞争风险检查
7. 竞争 panic输出
8. 终止golang 运行环境
9. 退出
```

<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-3.png" alt="生命周期" style="zoom:50%;" />  

- M0：M0 是第一个创建的线程，由 引用`runtime.m0`，它做系统初始化，先启动 G，然后 M0 变成普通 M，和其他的一样。
- G0：G0 是 M 启动时第一个创建的。G0 仅用于调度其他 G。每个 M 都有自己的 G0，G0 的内存栈用于系统调用或 goroutine 调度。全局变量`G0`是 M0 的 G0。

```go
package main
import "fmt"

func main() {
    fmt.Println("Hello world")
}
```

上面的代码将触发工作流：

1. 运行时创建 M0,G0 并绑定
2. 调度器初始化：初始 M0、堆栈、垃圾回收、创建和初始`GOMAXPROCS`P 列表
3. 上面代码中的 main 函数是`main.main`，`runtime.main`将调用`main.main`、创建 goroutine（只是称为 main goroutine）并将其推送到 P 的本地队列。
4. 启动 M0，M0 已经绑定到 P，所以它可以得到 main goroutine
5. M0根据goroutine的栈&调度信息设置运行环境
6. 在 M 中运行 G
7. G 存在，M 拉 Gs util`main.main`退出，`runtime.main`会调用 Defer & Panic，最后`runtime.exit`会被调用

相关资料

1. [Scalable Go Scheduler Design Doc](https://golang.org/s/go11sched) 
2. ` GMP` 调度模型源码：https://github.com/golang/go/blob/master/src/runtime/proc.go
3. https://studygolang.com/articles/33233
4. https://www.timqi.com/2020/05/15/how-does-gmp-scheduler-work/

