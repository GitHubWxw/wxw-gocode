## 并发编程之` goroutine` 



### 快速入门

- 主线程是一个物理线程，直接作用在CPU上的，是重量级的所以非常耗费CPU资源
- 协程是从主线程开启的，是轻量级的线程，是逻辑态，对资源消耗相对较小
- `Golang`的协程机制 重要的特点是 可以轻松的开启上万个协程，而其他编程语言的并发机制一般是基于线程的，开启过多的线程，资源耗费大，这就突显了` Golang` 在并发上的优势。

### 调度模型-MPG

#### 1. 传统的并发模式

多线程共享内存，这也是Java、C#或者C++等语言中的多线程开发的常规方法，其实golang语言也支持这种传统模式。

另外一种是Go语言特有的，也是Go语言推荐的：**CSP**（communicating sequential processes）并发模型。

不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。 “不要以共享内存的方式来通信，相反，要通过通信来共享内存。”

#### 2. 使用MPG模式实现CSP

在传统的并发中起很多线程只会加大CPU和内存的开销，太多的线程会大量的消耗计算机硬件资源，造成并发量的瓶颈。

- M指的是Machine，一个M直接关联了一个内核线程，是操作系统的主线程（是物理线程）。
- P指的是”processor”，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。
- G指的是Goroutine，协程，其实本质上也是一种轻量级的线程。

<img src="asserts/image-20211024232153604.png" alt="image-20211024232153604" style="zoom:67%;" /> 

理解：

- M关联了一个内核线程，通过调度器P（上下文）的调度，可以连接1个或者多个G,相当于把一个内核线程切分成了了N个用户线程；
- M和P是一对一关系（但是实际调度中关系多变），通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程就可以起N个Goroutine，同样硬件配置的机器可用的用户线程就成几何级增长，并发性大幅提高。

##### 2.1 MPG运行的状态1

可以看到操作系统线程、逻辑处理器和本地运行队列之间的关系。如果创建一个`  goroutine `并准备运行，这个 `  goroutine ` 就会被放到**调度器的全局运行队列**中。之后，调度器就将这些队列中的 `  goroutine ` 分配给一个逻辑处理器，并放到这个逻辑处理器对应的**本地运行队列**中，本地运行队列中的 `  goroutine ` 会一直等待直到自己被分配的逻辑处理器执行。

<img src="asserts/image-20211024233249839.png" alt="image-20211024233249839" style="zoom:67%;" />  

### 设置CPU运行数

为了充分利用多CPU的优势，在` Golang`程序中,设置运行的CPU数目

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	cpuNum := runtime.NumCPU()
	fmt.Println("cpuNum = ", cpuNum)

	// 可以设置使用多个CPU
	gomaxprocs := runtime.GOMAXPROCS(cpuNum - 1)
	fmt.Println("gomaxprocs = ",gomaxprocs)
}
```

- go 1.8 以后，默认让程序运行在多个核上，可以不用设置
- go 1.8 以前，还要设置一下，可以更高效的利用CPU

