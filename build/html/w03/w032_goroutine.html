<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. 并发编程之 goroutine &mdash; Go 深入浅出 1.0.0 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
        <script src="../_static/js/readmore.js"></script>
        <script src="../_static/js/baidutongji.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="第四章：数据操作" href="../w04/index.html" />
    <link rel="prev" title="1. 并发编程 概述" href="w031_summary.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Go 深入浅出
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w01/index.html">第一章：基础知识</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w02/index.html">第二章：面向对象</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">第三章：并发编程</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="w031_summary.html">1. 并发编程 概述</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2. 并发编程之<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">2.1. 快速入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">1. 并发问题</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">2. 并发通信</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gpm">2.2. 调度模型 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">1.  引言</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">2. 为什么需要调度器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gm">3. 弃用的 <code class="docutils literal notranslate"> <span class="pre">GM</span></code> 调度模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">4.<code class="docutils literal notranslate">&#160; <span class="pre">GPM</span></code> 调度模型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../w04/index.html">第四章：数据操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w05/index.html">第五章：源码学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../w06/index.html">第六章：工程实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wend/about.html">关于作者</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Go 深入浅出</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">第三章：并发编程</a> &raquo;</li>
      <li><span class="section-number">2. </span>并发编程之<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/w03/w032_goroutine.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="goroutine">
<h1><span class="section-number">2. </span>并发编程之<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code><a class="headerlink" href="#goroutine" title="永久链接至标题">¶</a></h1>
<p><code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 是Go语言中的轻量级线程实现，由Go运行时（runtime）管理。你将会发现，它的 使用出人意料得简单。</p>
<ul class="simple">
<li><p>并发的口号：不要通过共享内存来通信，而应该通过通信来共享内存。</p></li>
</ul>
<section id="id1">
<h2><span class="section-number">2.1. </span>快速入门<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<section id="id2">
<h3>1. 并发问题<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h3>
<p>假设我们需要实现一个函数Add()，它把两个参数相加，并将结果打印到屏幕上，具体代码 如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>那么，如何让这个函数并发执行呢?具体代码如下：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// 加入 go 关键字，开启协程</span>
<span class="k">go</span> <span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
</pre></div>
</div>
<p>是不是很简单?</p>
<p>你应该已经猜到，“go”这个单词是关键。与普通的函数调用相比，这也是唯一的区别。</p>
<p>在一个函数调用前加上go关键字，这次调用就会在一个新的<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 中并发执行。当被调用 的函数返回时，这个<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 也自动结束了。</p>
<p>需要注意的是，<strong>如果这个函数有返回值，那么这个 返回值会被丢弃</strong>。</p>
<p>好了，现在让我们动手试一下吧，还是刚才Add()函数：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在上面的代码里，我们在一个for循环中调用了10次Add()函数，它们是并发执行的。可是 当你编译执行了上面的代码，就会发现一些奇怪的现象:</p>
<ul class="simple">
<li><p>“什么？！屏幕上什么都没有，程序没有正常工作！</p></li>
<li><p>” 是什么原因呢？明明调用了10次Add()，应该有10次屏幕输出才对。要解释这个现象，就涉 及Go语言的程序执行机制了。</p></li>
</ul>
<p><strong>Go语言执行机制：</strong></p>
<p>Go程序从初始化main package并执行main()函数开始，当main()函数返回时，程序退出， 且程序并不等待其他 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> （非主<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> ）结束。</p>
<p>对于上面的例子，主函数启动了10个 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> ，然后返回，这时程序就退出了，而被启动的 执行Add(i, i)的 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 没有来得及执行，所以程序没有任何输出。</p>
<p>OK，问题找到了，怎么解决呢？</p>
<p>提到这一点，估计写过多线程程序的读者就已经恍然大悟， 并且摩拳擦掌地准备使用：</p>
<ul class="simple">
<li><p>类似 <code class="docutils literal notranslate"> <span class="pre">WaitForSingleObject</span></code> 之类的调用</p></li>
<li><p>或者写个自己很拿手的忙等待</p></li>
<li><p>或者 稍微先进一些的 <code class="docutils literal notranslate"> <span class="pre">sleep</span></code> 循环 <strong>等待来等待所有线程执行完毕</strong>。</p></li>
</ul>
<p>在Go语言中有自己推荐的方式，它要比这些方法都优雅得多。 要让主函数等待所有 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 退出后再返回，如何知道 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 都退出了呢?</p>
<p>这就引出了多个  <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 之间通信的问题。下面 我们将主要解决这个问题。</p>
</section>
<section id="id3">
<h3>2. 并发通信<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>从上面的例子中可以看到，关键字go的引入使得在Go语言中并发编程变得简单而优雅，但 我们同时也应该意识到并发编程的原生复杂性，并时刻对并发中容易出现的问题保持警惕。别忘 了，我们的例子还不能正常工作呢。</p>
<p>事实上，不管是什么平台，什么编程语言，不管在哪，并发都是一个大话题。话题大小通常 也直接对应于问题的大小。并发编程的难度在于协调，而协调就要通过交流。从这个角度看来，并发单元间的通信是最大的问题。</p>
<p>在工程上，有两种最常见的并发通信模型：<strong>共享数据</strong> 和 <strong>消息。</strong></p>
<ul class="simple">
<li><p><strong>共享数据</strong> 是指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。被共享的 数据可能有多种形式，比如内存数据块、磁盘文件、网络数据等。在实际工程应用中最常见的无疑是内存了，也就是常说的<strong>共享内存</strong>。</p></li>
<li><p><strong>消息机制</strong> 认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发 单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。这有点类似于进程 的概念，每个进程不会被其他进程打扰，它只做好自己的工作就可以了。不同进程间靠消息来通 信，它们不会共享内存。Go语言提供的消息通信机制被称为channel。</p></li>
</ul>
</section>
</section>
<section id="gpm">
<h2><span class="section-number">2.2. </span>调度模型 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code><a class="headerlink" href="#gpm" title="永久链接至标题">¶</a></h2>
<section id="id4">
<h3>1.  引言<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal notranslate"> <span class="pre">GPM(Goroutine-Processor-Machine)</span></code> 是 <code class="docutils literal notranslate"> <span class="pre">Golang</span></code> 语言的核心执行机制，为 <code class="docutils literal notranslate"> <span class="pre">Golang</span></code> 提供了可靠的高并发、低开销、网络通信友好的协程机制，同时为 <code class="docutils literal notranslate"> <span class="pre">channel</span></code> 机制提供了基础的保障。以 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code> 模型为树干，基本牵扯到了 <code class="docutils literal notranslate"> <span class="pre">golang</span></code> 调度策略、<code class="docutils literal notranslate"> <span class="pre">channel</span></code> 、网络通信、内存管理、垃圾回收、IL设计等一系列核心内容。个人感觉是理解 <code class="docutils literal notranslate"> <span class="pre">Golang</span></code> 设计/运行原理最好的入手点。</p>
<p>本次主要介绍 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code> 模型的演化和设计思想、执行流程和调度策略，如有分析不到位的地方欢迎指正。</p>
</section>
<section id="id5">
<h3>2. 为什么需要调度器<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>我们知道 <code class="docutils literal notranslate"> <span class="pre">Golang</span></code>  运行时有一个运行时。运行时在用户空间而不是内核中执行计划任务（<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> ），因此它更轻量级。它在系统资源使用和性能之间做了更好的权衡，尤其是在 IO 任务中。</p>
<section id="id6">
<h4>2.1 单进程时代<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>我们并不需要调度器，所有的任务都被序列化处理。这种模式有个明显的缺点：</p>
<ul class="simple">
<li><p>只有一个进程，计算机必须一项一项的处理任务</p></li>
<li><p>进程阻塞时会浪费CPU 时间</p></li>
</ul>
</section>
<section id="id7">
<h4>2.2 多进程/多线程时代<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<p>为了解决阻塞问题，我们可以让<code class="docutils literal notranslate"> <span class="pre">cpu</span></code> 在当前进程阻塞时执行其他任务。并且，我们创建了一个方法，将<code class="docutils literal notranslate"> <span class="pre">cpu</span></code> 时间划分为很小的时间片（大概<code class="docutils literal notranslate"> <span class="pre">10ms</span></code> ），并有时间限制地运行任务，以确保所有任务都可以执行。由于时间片的原因，所有任务似乎都在同一时间运行。</p>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-1.png" alt="process scheduling" style="zoom:50%;" />  <p>同时，CPU 还要处理进程所持有的上下文切换，创建、切换、销毁进程会消耗大量的系统资源。所以高并发情况下CPU有效使用率可能会偏低。在linux系统中，线程虽然重量更轻，但它们是CPU调度的基本单位。进度成本原则上类似于流程。</p>
</section>
<section id="id8">
<h4>2.3 协程的由来<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h4>
<p>更多进程/线程也会导致其它问题：</p>
<ol class="simple">
<li><p>内存占用高。在 32 位系统中，每个进程将使用<code class="docutils literal notranslate">&#160; <span class="pre">4GB</span></code> 虚拟内存。每个线程至少要花费 <code class="docutils literal notranslate"> <span class="pre">4MB</span></code> 。</p></li>
<li><p>上下文切换时 CPU 使用率高。</p></li>
</ol>
<p>工程师发现大部分消耗发生在内核空间。我们知道一个进程有“用户空间”和“内核空间”，当系统调用或时间片触发时，进程会进入内核空间……但是从操作系统的角度来看，不管它是什么状态，由操作系统控制的进程使用一个数据结构称为<code class="docutils literal notranslate"><span class="pre">PCB</span> <span class="pre">Process</span> <span class="pre">Control</span> <span class="pre">Block</span></code>. OS看不到协程的工作状态，它只关心线程或PCB结构。</p>
<ul class="simple">
<li><p>我们可以将运行在内核空间的代码称为线程 （<code class="docutils literal notranslate"><span class="pre">thread</span></code>）.</p></li>
<li><p>可以将运行在用户空间的代码称为协程<code class="docutils literal notranslate"><span class="pre">Coroutine</span></code>。</p></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-2.png" alt="线程协程" style="zoom:50%;" />  <p>那么为了减少内核空间的消耗，我们是否应该将多个协程绑定到一个线程？当然是的。如果我们<code class="docutils literal notranslate"><span class="pre">schedule</span> <span class="pre">layer</span></code>在线程和协程之间添加一个，将 N 个协程绑定到一个线程，我们得到一个<code class="docutils literal notranslate"><span class="pre">N:1</span></code>模式。</p>
<p>在这种情况下，我们可以在用户空间完成大部分工作，而不是频繁切换到内核。但是一旦线程被阻塞，所有的协程都不能工作。并且多核 CPU 不能仅在一个物理线程中全速运行。</p>
<p><strong>继续优化调度器</strong> ，我们可以将N个协程绑定到M个物理线程。更复杂的调度器可以结合多线程的性能和协程的轻量级。</p>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-3.png" alt="男：女" style="zoom:50%;" />  <p>线程和协程调度的区别：</p>
<ul class="simple">
<li><p>在于<strong>线程调度是抢占式</strong>的，</p></li>
<li><p><strong>协程是协作式</strong>的，协程应该主动释放CPU。</p></li>
</ul>
</section>
<section id="id9">
<h4>2.4 协程 时代<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h4>
<p>在协程模式下，开发者应该主动释放 CPU。当一个协程长时间占用 CPU，而其他协程很饿时，这可能会导致问题。</p>
<p>所以在 <code class="docutils literal notranslate"><span class="pre">golang</span></code>中，scheduler是抢占式的，<code class="docutils literal notranslate"> <span class="pre">golang</span></code> 中的tasks命名为<code class="docutils literal notranslate"><span class="pre">goroutine</span></code>，通过channel进行通信共享数据。</p>
<p><code class="docutils literal notranslate"><span class="pre">goroutines</span> <span class="pre">can</span> <span class="pre">run</span> <span class="pre">when</span> <span class="pre">other</span> <span class="pre">goroutine</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">same</span> <span class="pre">thread</span> <span class="pre">blocked,</span> <span class="pre">runtime</span> <span class="pre">will</span> <span class="pre">help</span> <span class="pre">you</span> <span class="pre">do</span> <span class="pre">the</span> <span class="pre">scheduling,</span> <span class="pre">you</span> <span class="pre">have</span> <span class="pre">noting</span> <span class="pre">to</span> <span class="pre">do.</span></code>. 它是为多并发场景实现的，比如多进程与单进程。<code class="docutils literal notranslate"> <span class="pre">Goroutine</span></code> 保留了协程的优点并具有更高的性能。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 只能通过<code class="docutils literal notranslate"><span class="pre">4KB</span></code>内存来设置。它非常轻巧。</p></li>
</ul>
</section>
</section>
<section id="gm">
<h3>3. 弃用的 <code class="docutils literal notranslate"> <span class="pre">GM</span></code> 调度模型<a class="headerlink" href="#gm" title="永久链接至标题">¶</a></h3>
<p>线程和<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 的关系我们已经知道了，这里的重点是<code class="docutils literal notranslate"><span class="pre">The</span> <span class="pre">Scheduler</span></code>.</p>
<p>现在在 <code class="docutils literal notranslate"> <span class="pre">golang</span></code>中使用的调度器是2012年重新设计的，因为存在性能问题，所以弃用了。下面简单介绍一下这个调度器的工作原理。</p>
<ul class="simple">
<li><p><strong>G：</strong> 协程</p></li>
<li><p><strong>M：</strong> 机器，内核空间中的线程</p></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-14-4.png" alt="通用调度器" style="zoom:50%;" />  <p>使用全局队列，它有缺点：</p>
<ol class="simple">
<li><p>要创建、销毁、调度 G ，M 需要进行激烈的锁定竞争</p></li>
<li><p>在 M 之间转移 G 会造成更多的额外消耗。比如M创建了一个新的<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code>  G’，要执行G’，它应该被推入队列并在其他M’中运行，G与G’有关系，所以这里本地性能很差</p></li>
<li><p>频繁的系统调用导致线程阻塞增加系统消耗</p></li>
</ol>
</section>
<section id="id10">
<h3>4.<code class="docutils literal notranslate">&#160; <span class="pre">GPM</span></code> 调度模型<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<section id="id11">
<h4>4.1 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code> 模型介绍<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h4>
<p><strong><code class="docutils literal notranslate"> <span class="pre">Goroutine</span></code> 调度器和 OS 调度器使用 M 连接，每个 M 是一个物理 OS 线程，OS 调度器调度 M 运行在一个真实的 CPU 内核中。</strong></p>
<p>在这种模式中，线程是物理工作者，调度程序应该将 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 分派给一个线程。</p>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-1.jpeg" alt="GMP模式" style="zoom:50%;" />  <p><strong>G、P、M 职责</strong></p>
<ul class="simple">
<li><p><strong>G：</strong> <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code>，go程序建立的用户线程。主要保存 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code>  的运行时栈信息（stack结构体）以及 CPU 的一些寄存器的值（<code class="docutils literal notranslate"> <span class="pre">gobuf</span></code> 结构体），还有关联的M，全局队列中下个G等信息。</p></li>
<li><p><strong>P：</strong> processor 代表了<code class="docutils literal notranslate"><span class="pre">M</span></code>所需的上下文环境，也是处理用户级代码逻辑的处理器，可以看作一个局部调度器使go代码在一个线程上跑。</p></li>
<li><p><strong>M：</strong> machine 一个<code class="docutils literal notranslate"><span class="pre">M</span></code>直接关联一个os内核线程，用于执行G。 <code class="docutils literal notranslate"><span class="pre">M</span></code>会优先从关联的<code class="docutils literal notranslate"><span class="pre">P</span></code>的本地队列中直接获取待执行的<code class="docutils literal notranslate"><span class="pre">G</span></code>，它保存了 M 自身使用的栈信息、当 前正在 M 上执行的 G 信息、与之绑定的 P 信息。</p></li>
<li><p><strong>P列表</strong>：在创建程序的时候创建一个<code class="docutils literal notranslate"><span class="pre">P</span></code>列表， 最多有<code class="docutils literal notranslate"> <span class="pre">$GOMAXPROCS</span></code>个，这环境变量可以通过操作系统中的环境变量设置（<code class="docutils literal notranslate"> <span class="pre">1W)</span></code> ），也可以通过Go程序中的<code class="docutils literal notranslate"> <span class="pre">runtime.GOMAXPROCS()</span></code> 函数设置，默认为处理器的核心数，它代表了真正的并发度。</p></li>
<li><p><strong>M列表</strong>：当前操作系统分配到当前go程序的内核线程数，可以通过go语言中runtime/debug包中的<code class="docutils literal notranslate"> <span class="pre">SetMaxThreads</span></code> 函数设置。当有一个<code class="docutils literal notranslate"><span class="pre">M</span></code>阻塞，会有一个新的M被创建；当有一个<code class="docutils literal notranslate"><span class="pre">M</span></code>空闲，会被回收或睡眠。</p></li>
<li><p><strong>P的本地队列</strong>：P维护一个runq_用来存放等待执行的<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> ，新创建的<code class="docutils literal notranslate"><span class="pre">G</span></code>会优先放在<code class="docutils literal notranslate"><span class="pre">P</span></code>的本地队列，当本地队列满（<code class="docutils literal notranslate"> <span class="pre">256G</span></code> ）时，会放入<code class="docutils literal notranslate"><span class="pre">G</span></code>的全局队列。</p></li>
<li><p><strong>全局队列</strong>：如果<code class="docutils literal notranslate"><span class="pre">P</span></code>的本地队列已满，待执行的<code class="docutils literal notranslate"><span class="pre">G</span></code>就会放在全局队列中，<code class="docutils literal notranslate"><span class="pre">M</span></code>会先从关联的<code class="docutils literal notranslate"><span class="pre">P</span></code>的<strong>本地队列中获取</strong>待执行的<code class="docutils literal notranslate"><span class="pre">G</span></code>，没有的话，再到<strong>全局队列</strong>中获取；如果这里也没有了，就去<strong>其他<code class="docutils literal notranslate"><span class="pre">P</span></code>的本地队列</strong>中获取一些任务。</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">GPM</span></code> 模型 在原有的GM模型基础上，引入 P层，<strong>目标是解决</strong>：</p>
<ol class="simple">
<li><p>全局队列共享锁引发的性能问题，同时使得本地P中的G无锁化，空间局部性更好</p></li>
<li><p>将M 层 <code class="docutils literal notranslate"> <span class="pre">Mcache</span></code> 下沉到P层，减少内存占用</p></li>
<li><p>因频繁挂起引发大切换代价大幅下降</p></li>
</ol>
<p><strong>关于 P和 M的数量设置</strong></p>
<ul class="simple">
<li><p><strong>P的数量</strong>： 由运行时包中的<code class="docutils literal notranslate"><span class="pre">GOMAXPROCS</span></code>环境变量或<code class="docutils literal notranslate"><span class="pre">GOMAXPROCS()</span></code>函数决定。这意味着有 <code class="docutils literal notranslate"> <span class="pre">PRAGMATICS</span></code>  协程在任何时候并发运行。</p></li>
<li><p><strong>M的数量：</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"> <span class="pre">golang</span></code>  支持的最大线程数是 10000，但是 OS 通常不能创建这么多线程。所以我们可以忽略这个限制。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SetMaxThreads()</span></code> 运行时/调试包中的函数可以设置最大线程数</p></li>
<li><p><strong>一旦当前线程被阻塞，它将创建一个新线程 ，当有一个<code class="docutils literal notranslate"><span class="pre">M</span></code>空闲，会被回收或睡眠。</strong></p></li>
</ul>
</li>
</ul>
<p><strong>注意：</strong> M&amp;P的编号没有关系。一旦当前 M 被阻塞，P 的 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code>  将在其他 M 中运行或创建一个新 M。所以即使 P 的数量是 1，也可能有太多的 M。</p>
<p>**什么时候 创建 P、M **</p>
<ul class="simple">
<li><p><strong>P</strong>：<code class="docutils literal notranslate"><span class="pre">P</span></code>的个数确定后，由runtime创建。</p></li>
<li><p><strong>M：</strong> 如果没有足够的 M 来执行 P 的任务，则会创建它。例如，所有 M 都被阻止，将创建新的 M 来运行 P 的任务</p></li>
</ul>
</section>
<section id="id12">
<h4>4.2 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code> 调度策略<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h4>
<p><strong>重用</strong>：重用线程，避免频繁创建、销毁线程。</p>
<ol class="simple">
<li><p>工作窃取：当没有 G 运行时，从 P 绑定的 P 中窃取 G，而不是销毁</p></li>
<li><p>Hand Off：当P被阻塞时，将P转移给其他空闲的M</p></li>
</ol>
<p><strong>并发</strong> ：有更多<code class="docutils literal notranslate">&#160; <span class="pre">GOMAXPROCS</span></code>  协程同时运行。但是如果<code class="docutils literal notranslate">&#160; <span class="pre">GOMACPROCS</span> <span class="pre">&lt;</span> <span class="pre">CPU</span> <span class="pre">Cores</span></code> ，它也会设置并发限制。</p>
<p>**Preemptive(先发制人) ** ：协程必须主动放弃<code class="docutils literal notranslate"> <span class="pre">cpu</span></code> 时间。但是在<code class="docutils literal notranslate"> <span class="pre">golang</span></code> 中，一个<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 最多可以运行<code class="docutils literal notranslate"> <span class="pre">10ms</span></code> ，避免其他<code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 饿死。</p>
<p><strong>全局 <code class="docutils literal notranslate"> <span class="pre">Goroutines</span></code>  队列</strong>：当工作窃取失败时，M 可以从全局队列中拉取 <code class="docutils literal notranslate"> <span class="pre">goroutines</span></code>。</p>
</section>
<section id="id13">
<h4>4.3  <code class="docutils literal notranslate"><span class="pre">GPM</span></code>工作流程<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">func(){}</span> <span class="pre">之后发生了什么</span></code></p>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-2.jpeg" alt="img" style="zoom: 67%;" />  <ol class="simple">
<li><p>通过 <code class="docutils literal notranslate"> <span class="pre">go</span> <span class="pre">func()</span> <span class="pre">{}</span></code>  创建一个 <code class="docutils literal notranslate"> <span class="pre">goroutine</span></code> 。</p></li>
<li><p>有两个队列可以存储G，本地队列是更好的选择，但如果本地已满，G将被发布到全局队列。</p></li>
<li><p>G 必须在 M 中运行，每个 M 对应一个 P，M 会在任务完成时从此 P 中拉出 goroutine。如果本地 P 为空，它将从其他 M 的 P 或全局队列中窃取。</p></li>
<li><p>M 持续运行以执行 goroutines</p></li>
<li><p>当 M 被阻塞时，<code class="docutils literal notranslate"> <span class="pre">Golang</span></code>  会将其与 P 分离，并在其他空闲 M 中运行 Gs 或创建一个新的 M。</p></li>
<li><p>当 M 恢复时，TG 触发阻塞，将尝试获取一个空闲的 P，如果没有 P 空闲，M 将休眠，G 将被发布到全局队列。</p></li>
</ol>
</section>
<section id="id14">
<h4>4.4 <code class="docutils literal notranslate"> <span class="pre">GPM</span></code>生命周期<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>和其它的语言设计类似，<code class="docutils literal notranslate"><span class="pre">Golang</span></code> 在启动时并不是从我们写的 <code class="docutils literal notranslate"> <span class="pre">main.main</span></code> 启动，而是在外面包了一层 <code class="docutils literal notranslate"> <span class="pre">runtime.main</span></code> 作为启动的入口。对于<code class="docutils literal notranslate"><span class="pre">golang</span></code> 本身来说：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span> <span class="nx">设置运行参数</span>
<span class="mf">2.</span> <span class="nx">启动</span> <span class="nx">sysmon</span> <span class="nx">作为监控</span>
<span class="mf">3.</span> <span class="nx">启动</span> <span class="nx">GC</span> <span class="nx">机制</span>
<span class="mf">4.</span> <span class="nx">启动</span> <span class="nx">panic</span> <span class="nx">保护</span>
<span class="mf">5.</span> <span class="nx">调用</span> <span class="nx">main</span><span class="p">.</span><span class="nx">main</span> <span class="nx">执行用户代码</span>
<span class="mf">6.</span> <span class="nx">竞争风险检查</span>
<span class="mf">7.</span> <span class="nx">竞争</span> <span class="nx">panic输出</span>
<span class="mf">8.</span> <span class="nx">终止golang</span> <span class="nx">运行环境</span>
<span class="mf">9.</span> <span class="nx">退出</span>
</pre></div>
</div>
<img src="https://cdn.jsdelivr.net/gh/timqi/Blog@gh-pages/i/2020-05-15-3.png" alt="生命周期" style="zoom:50%;" />  <ul class="simple">
<li><p>M0：M0 是第一个创建的线程，由 引用<code class="docutils literal notranslate"><span class="pre">runtime.m0</span></code>，它做系统初始化，先启动 G，然后 M0 变成普通 M，和其他的一样。</p></li>
<li><p>G0：G0 是 M 启动时第一个创建的。G0 仅用于调度其他 G。每个 M 都有自己的 G0，G0 的内存栈用于系统调用或 goroutine 调度。全局变量<code class="docutils literal notranslate"><span class="pre">G0</span></code>是 M0 的 G0。</p></li>
</ul>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的代码将触发工作流：</p>
<ol class="simple">
<li><p>运行时创建 M0,G0 并绑定</p></li>
<li><p>调度器初始化：初始 M0、堆栈、垃圾回收、创建和初始<code class="docutils literal notranslate"><span class="pre">GOMAXPROCS</span></code>P 列表</p></li>
<li><p>上面代码中的 main 函数是<code class="docutils literal notranslate"><span class="pre">main.main</span></code>，<code class="docutils literal notranslate"><span class="pre">runtime.main</span></code>将调用<code class="docutils literal notranslate"><span class="pre">main.main</span></code>、创建 goroutine（只是称为 main goroutine）并将其推送到 P 的本地队列。</p></li>
<li><p>启动 M0，M0 已经绑定到 P，所以它可以得到 main goroutine</p></li>
<li><p>M0根据goroutine的栈&amp;调度信息设置运行环境</p></li>
<li><p>在 M 中运行 G</p></li>
<li><p>G 存在，M 拉 Gs util<code class="docutils literal notranslate"><span class="pre">main.main</span></code>退出，<code class="docutils literal notranslate"><span class="pre">runtime.main</span></code>会调用 Defer &amp; Panic，最后<code class="docutils literal notranslate"><span class="pre">runtime.exit</span></code>会被调用</p></li>
</ol>
<p>相关资料</p>
<ol class="simple">
<li><p><a class="reference external" href="https://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a></p></li>
<li><p><code class="docutils literal notranslate"> <span class="pre">GMP</span></code> 调度模型源码：https://github.com/golang/go/blob/master/src/runtime/proc.go</p></li>
<li><p>https://studygolang.com/articles/33233</p></li>
<li><p>https://www.timqi.com/2020/05/15/how-does-gmp-scheduler-work/</p></li>
</ol>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="w031_summary.html" class="btn btn-neutral float-left" title="1. 并发编程 概述" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../w04/index.html" class="btn btn-neutral float-right" title="第四章：数据操作" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2021, 公众号:Java半颗糖.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>